# %% [markdown]
# # Why is do we need to hand in a text??
# I think it would make way more sense to hand in a zip folder, this would allow us to submit multiple files, images and juypter notebooks

# # Primes
# ## finding primes


# %%
def get_primes(max : int):
    primes = set()
    for i in range(2, max):
        is_prime = True
        for j in range(2, i):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.add(i)
    return list(primes)


print(get_primes(100))


# %% [markdown]
# ## Timing my function


# %%
import timeit
timeit.timeit(lambda: get_primes(10_000), number = 3)


# %% [markdown]
# # Sea level rise
# ## reading the data


# %%
import pandas as pd


sea_level_data = pd.read_csv('ex_01\SeaLevel.txt', header=None, names=['time_y', 'sea_level_mm'], sep='\s+')


print(sea_level_data.head())


# %% [markdown]
# ## line fit onto the entire data


# %%
import numpy as np
import matplotlib.pyplot as plt


linear_coeffs= np.polyfit(sea_level_data['time_y'], sea_level_data['sea_level_mm'], 1)


time = np.linspace(sea_level_data['time_y'].min(), sea_level_data['time_y'].max(), 100)
poly = np.polyval(linear_coeffs, time)


plt.title('Sea Level Rise')
plt.title('Sea Level Rise')
plt.xlabel('Year')
plt.ylabel('Sea Level [mm]')
plt.scatter(sea_level_data['time_y'], sea_level_data['sea_level_mm'], marker= '.')
plt.plot(time, poly, color='red')
plt.grid()
plt.show()




# %%
intervall_1 = sea_level_data[(sea_level_data['time_y'] >= 1993) & (sea_level_data['time_y'] < 2000)]
intervall_2 = sea_level_data[(sea_level_data['time_y'] >= 2000) & (sea_level_data['time_y'] < 2024)]


coeffs_1 = np.polyfit(intervall_1['time_y'], intervall_1['sea_level_mm'], 1)
coeffs_2 = np.polyfit(intervall_2['time_y'], intervall_2['sea_level_mm'], 1)


# %% [markdown]
# ## Making a nice figure


# %%
time_1 = np.linspace(1993, 2000, 100)
time_2 = np.linspace(2000, 2024, 100)


plt.figure(figsize=(10, 5))
plt.title('Sea Level Rise')
plt.xlabel('Year')
plt.ylabel('Sea Level [mm]')


plt.scatter(intervall_1['time_y'], intervall_1['sea_level_mm'], marker= '.', label='data : 1993-2000')
plt.scatter(intervall_2['time_y'], intervall_2['sea_level_mm'], marker= '.', label='data : 2000-2024')
plt.plot(time_1, np.polyval(coeffs_1, time_1), color='red', label=f'fit, slope : {coeffs_1[0]:.3f} [mm/year]')
plt.plot(time_2, np.polyval(coeffs_2, time_2), color='green', label=f'fit, slope : {coeffs_2[0]:.3f} [mm/year]')
plt.grid()
plt.legend()


plt.savefig('sea_level_rise.png')
plt.show()


# %% [markdown]
# ## Diffrence between mean of time and 0-th order fit


# %% [markdown]
# The coefficient that is generated by the 0th order is the parameter $\hat{y}_0$ that minimizes
# $$
# \sum_{i=1}^N (y^{(i)} - \hat{y}_0)^2
# $$
# this can be solved for
# $$
# \hat{y}_0 = \frac{1}{N} \sum_{i=1}^N y^{(i)} = \operatorname{avg}_i (y^{(i)})
# $$
# While the mean along the time series is the average of the "other axis", i.e.
# $$
# \operatorname{avg}_i (x^{(i)})
# $$


# %%
coef = np.polyfit(sea_level_data['time_y'], sea_level_data['sea_level_mm'], 0)
mean_of_time = np.mean(sea_level_data['time_y'])
print(coef[0], '[mm]')
print(mean_of_time, '[year]')


# %% [markdown]
# ## Quadratic coefficients including units


# %%
quad_coeffs = np.polyfit(sea_level_data['time_y'], sea_level_data['sea_level_mm'], 2)
print(f'Coefficients: {quad_coeffs}')
print(f'coeffs[2]: {quad_coeffs[2]:.3f} [mm]')
print(f'coeffs[1]: {quad_coeffs[1]:.3f} [mm/year]')
print(f'coeffs[0]: {quad_coeffs[0]:.3f} [mm/year^2]')


# %% [markdown]
# # Shifted Quadratic fit
#
# The coefficients change because `polyfit` simply tries to mach a polynomial of the form $y = ax^2 + bx + c$ to our data $\{x^{(i)}, y^{(i)}\}$. If we shift the $x$-Values the coefficients obviously change too. We can compute the new coefficents from the old onw when we concider what happens when we try to shift a $2$-order polynomial $x_0$ to the left
# $$
# y = a(x+x_0)^2 + b(x+x_0) + c' = \underbrace{a}_{a'}x^2 + \underbrace{(b+2ax_0)}_{b'}x + \underbrace{(c + bx_0 + ax_0^2)}_{c'}
# $$


# %%
x_0 = sea_level_data['time_y'].min()


new_quad_coeffs = np.polyfit(sea_level_data['time_y']-x_0, sea_level_data['sea_level_mm'], 2)

new_quad_coeffs_via_formula = np.zeros_like(quad_coeffs)
new_quad_coeffs_via_formula[0] = quad_coeffs[0]
new_quad_coeffs_via_formula[1] = quad_coeffs[1] + 2 * quad_coeffs[0] * x_0
new_quad_coeffs_via_formula[2] = quad_coeffs[2] + quad_coeffs[1] * x_0 + quad_coeffs[0] * x_0 ** 2

assert np.allclose(new_quad_coeffs, new_quad_coeffs_via_formula)

print(f'Coefficients: {new_quad_coeffs}')
print(f'coeffs[2]: {new_quad_coeffs[2]:.3f} [mm]')
print(f'coeffs[1]: {new_quad_coeffs[1]:.3f} [mm/year]')
print(f'coeffs[0]: {new_quad_coeffs[0]:.3f} [mm/year^2]')